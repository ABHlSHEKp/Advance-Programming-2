//Two Sum
//CPP//

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> Hmap;

        for (int i = 0; i < nums.size(); i++) {
            int diff = target - nums[i];
            if (Hmap.find(diff) != Hmap.end()) {
                return {i, Hmap[diff]};
            }
            Hmap[nums[i]] = i;
        }
        return {};
    }
};


//Three Sum
//python//

class Solution(object):
    def threeSum(self, nums):
        nums.sort()
        s=set()
        output= []
        for i in range(len(nums)):
            j=i+1
            k= len(nums)-1
            while j<k: 
                sum=nums[i]+nums[j]+nums[k]
                if sum==0:
                    s.add((nums[i],nums[j],nums[k]))
                    j+=1
                    k-=1
                elif sum <0:
                    j+=1
                else:
                    k-=1
        output=list(s)
        return output


//Remove-duplicates-from-sorted-array
//java//

class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 1;
        for (int i = 1; i < nums.length; i++) {
        if (nums[i] != nums[i - 1]) {
        nums[j] = nums[i];
        j++;
        }
       }
      return j;
    }
}

//Remove-element
//java//

class Solution{
  public int removeElement(int[] nums, int val) {
       int index= 0;
    for(int i =0; i<nums.length; i++)
    {
        if (nums[i]!= val)
        {
            nums[index]=nums[i];
            index++;
        }
    }return index++;
  }
}

//Jump Game 
//CPP//

class Solution {
public:
    int jump(vector<int>& nums) {
        // Initialize variables to track the number of jumps,
        // the end of the current jump range, and the farthest reachable index
        int jumps = 0, curEnd = 0, curFarthest = 0;

        // Iterate through the array, stopping before the last element
        for (int i = 0; i < nums.size() - 1; i++) {
            // Update the farthest position we can reach from the current index
            curFarthest = max(curFarthest, i + nums[i]);

            // If we reach the end of the current jump range
            if (i == curEnd) {
                // Increment the jump counter
                jumps++;
                // Update the current jump range to the farthest reachable index
                curEnd = curFarthest;

                // Optional: Early exit if the current jump already covers the last index
                if (curEnd >= nums.size() - 1) {
                    break;
                }
            }
        }

        // Return the total number of jumps needed
        return jumps;
    }
};

//Contains-duplicate
//Java//

class Solution{
    public boolean containsDuplicate(int[]nums){
        HashMap<Integer, Integer> a= new HashMap<>();
        for(int i =0; i<nums.length; i++)
        {
            if (a.containsKey(nums[i]))
            {
                return true;
            }
            a.put(nums[i],1);
        }
        return false;
    }
}

//Merge sorted Array
//Java//

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i= m-1;
        int j= n-1;
        int k= m+n-1;
        while(j>=0){
            if(i>=0 && nums1[i]>nums2[j])
            {
                nums1[k--]=nums1[i--];
            }
            else
            {
                nums1[k--]=nums2[j--];
            }
        }
       
}
}
